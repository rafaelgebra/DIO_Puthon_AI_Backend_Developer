Operadores aritimeticos.

produto1 = 20
produto2 = 10

print(f'{produto1 + produto2}')
print(f'{produto1 - produto2}')
print(f'{produto1 / produto2}')
print(f'{produto1 // produto2}')
print(f'{produto1 * produto2}')
print(f'{produto1 % produto2}')
print(f'{produto1 ** produto2}')

Tipod de operadores de comparação.

saldo = 200
saque = 200

print(saldo == saque)
print(saldo != saque)
print(saldo > saque)
print(saldo > saque)
print(saldo >= saque)
print(saldo <= saque)

Operadores de atribuição

saldo = 500
print(saldo)
saldo += 200
print(saldo)
saldo -= 100
print(saldo)
saldo *= 2
print(saldo)
saldo /= 4
print(saldo)
saldo //= 5
print(saldo)
saldo **= 3
print(saldo)
saldo %= 299
print(saldo)
saldo **= 3
print(saldo)


Operadores Lógicos

and
or
not

saldo = 1000
saque = 100
limite = 100

total = saldo >= saque and saque <= limite
if total == True:
    print("Saque aprovado")
    print(f"Valor sacado {saque} Saldo atual {saldo - saque}")


Operador de identidade

is
not is

Operador de associação

in
not in

<!--Metodos úteis em string-->

cruso = "pYthon"

print(curso.upper())
>>> PYTHON

print(curso.lower())
>>> python

print(curso.title())
>>> Python

pritn(curso.strip())<!-- Retira espaço em branco das laterais-->

print(curso.lstrip())<!-- Retira o espado do lado esquerdo-->

print(cruso.rstrip())<!-- Retira o espaço do lado direto-->

pritn(curso.center(10, "#"))<!-- Fas a junção e a centralização da string-->
>>> "##Python##" 

print(".".join(curso))
>>> "P.y.t.h.o.n"

<!-- Interpolação de Variáveis-->

O uso de % é chamado de Old style - não é mais usado.

O metodo formate ainda é usado.

<!-- Lista  -->

teste = ["F","a","t","i","a","m","e","n","t","o"]
print(teste[2:])
print(teste[:2])
print(teste[1:3])
print(teste[0:-1:2])
print(teste[::])
print(teste[::-1])

teste2 = ["Fatiamento"]
print([0][2:])
print(teste2[0][:2])
print(teste2[0][1:3])
print(teste2[0][0:-1:2])
print(teste2[0][::])
print(teste2[0][::-1])
print()
for letra in teste:
    print(letra, end="")
print()

carros = ["gol", "celta", "palio"]

for indice, carro in enumerate(carros):
    print(f"{indice}: {carro}")


    numeros = [1, 30, 21, 2, 9, 65, 34]
pares = []

for numero in numeros:
    if numero % 2 == 0:
        pares.append(numero)

print(numeros)
print(pares)

pares = [numero for numero in numeros if numero % 2 == 0]

print(pares)

quadrado = [numero ** 2 for numero in numeros]
print(quadrado)


lista = []

lista.append(1)
lista.append("Python")
lista.append([40, 30, 20])

print(lista)
print(lista[0])
print(lista[1])
print(lista[2])
print(lista[2][1])

lista2 = lista.copy()
lista.clear()

print(lista2)
print(lista)


cores = ["Vermelho", "Azul", "Verde", "Azul"]
print(cores.count("Vermelho"))
print(cores.count("Azul"))
print(cores.count("Verde"))

linguagens = ["Python", "Js", "C", "Java", "csharp"]

print(linguagens.pop())
print(linguagens.pop())
print(linguagens.pop())
print(linguagens.pop())
print(linguagens.pop())
print(linguagens.pop(0))



linguagens = ["Python", "Js", "C", "Java", "csharp"]

linguagens.sort()
print(linguagens)
linguagens.sort(reverse=True)
print(linguagens)
linguagens.sort(key=lambda x: len(x))
print(linguagens)
linguagens.sort(key=lambda x: len(x), reverse=True)
print(linguagens)


linguagens = ["Python", "Js", "C", "Java", "csharp"]

print(sorted(linguagens))

print(sorted(linguagens, key=lambda x: len(x)))

print(sorted(linguagens, key=lambda x: len(x), reverse=True))

print([n**2 if n > 6 else n for n in range(10) if n % 2 == 0])

for n in range(10):
    if n % 2 == 0:
        print(n**2 if n > 6 else n)


<!-- Tuplas -->

frutas = ("laranja", "pera", "uva",)

letras = tuple("python")

numeros = tuple([1,2,3,4])

pains = ("brasil",)

print(frutas[0])
print(frutas[2])
print(frutas[-1])
print(frutas[-3])

matriz = (
    (1, "a", 2),
    ("b", 3, 4),
    (6, 5, "c"),
)
for elemento in matriz:
    print(elemento)
print()
print(matriz[0])
print(matriz[0][0])
print(matriz[0][-1])
print(matriz[-1][-1])

<!-- Conjuntos SETS -->

Um SET é uma coleção que não possui objeto repetidos, usando SETS para representar o conjuntos matématicos ou eliminar itnes duplicados de um iterpavel.

lista = set([1, 2, 3, 1, 3, 4])
print(lista)

lista = set("abacaxi")
print(lista)

carros = set(("palio", "gol", "celta", "palio"))
print(carros)

linguagens = {"python", "java", "python"}
print(linguagens)

numeros = {1, 2, 3, 2}
numeros = list(numeros)
print(numeros)

conjunto_a = {1, 2}
conjunto_b = {3, 4}
print(conjunto_b.union(conjunto_a))

conjunto_a = {1, 2, 3}
conjunto_b = {2, 3, 4}
print(conjunto_a.intersection(conjunto_b))

print(conjunto_b.difference(conjunto_a))
print(conjunto_a.difference(conjunto_b))

print(conjunto_a.symmetric_difference(conjunto_b))

conjunto_a = {1, 2, 3}
conjunto_b = {4, 1, 2, 5, 6, 3}
print(conjunto_a.issuperset(conjunto_b))
print(conjunto_b.issuperset(conjunto_a))

conjunto_a = {1, 2, 3, 4, 5}
conjunto_b = {6, 7, 8, 9}
conjunto_c = {1, 0}

print(conjunto_a.isdisjoint(conjunto_b))
print(conjunto_a.isdisjoint(conjunto_c))

sorteio = {1, 23}
print(sorteio)

sorteio.add(25)
print(sorteio)
sorteio.add(42)
print(sorteio)
sorteio.add(25)
print(sorteio)

numeros = {1, 2, 3, 1, 2, 4, 5, 5, 6, 7, 8, 9, 0}
print(numeros)
numeros.discard(1)
print(numeros)
numeros.discard(45)
print(numeros)

print(numeros.pop())
print(numeros.pop())
print(numeros.pop())
print(numeros.pop())
print(numeros.pop())
print(numeros)


numeros = {1, 2, 3, 1, 2, 4, 5, 5, 6, 7, 8, 9, 0}
numeros.remove(0)
print(numeros)
numeros.discard(0)
print(numeros)


print(1 in numeros)
print(10 in numeros)


<!-- Dicionarios -->

pessoa = {"nome": "Rafael", "idade": 35}

pessoa = dict(nome="Rafael", idade=35) <!-- Consultor/classe: dict. -->

pessoa["telefone"] = "333-1234"

print(pessoa["nome"])
print(pessoa["idade"])

pessoa["nome"] = "Thatiane"

print(pessoa)


contatos = {
    "guilherme@gmail.com": {"noome": "Guilherme", "telefone": "3333-2221"},
    "rafael@gmail.com": {"nome": "Rafael", "telefone": "3322-1234"}
}

for chave in contatos:
    print(chave, contatos[chave])


for chave, valor in contatos.items():
    print(chave, valor)


    --Metodos

contatos.clear()
contato.copy()

Com o fromkeys consegui criar a chave sozinho
dict.fromkeys(["nome", telefone]) <!-- Sem vincular valor-->

dict.fromkeys(["nome", "teledone"], "vazio") <!-- Cria as chaves porém é adicionado um valor padrão das chaves-->

contatos.get("chave") <!-- consegue procurar se a chave existe no dicionario. -->

contatos.get("chave", {}) <!-- Se não achar a chave, retorna um dicionario-->

print(contatos.get("chave"))
print(contatos.get("chave", {}))

print(contatos)

contato.pop() <!-- remove e retorna o que removel-->


contato.setdefault()<!-- se exister já a chave ele não altera o valor, e se não existir ele cria-->

contatos.update() <!-- atualiza o dicionario com outro dicionario-->

contatos.keys() <!-- retorna só as chaves-->
contatos.values <!-- retorna só os valores do dicionario-->

del contatos["guilherme@gmail.com"]["telefone"]


<!-- Funções -->

Função e um bloco de código identidicado por um nome e pode receder uma lista de parâmetros, esse parâmetros pode ou não ter valores padrões. Usar funções torna o código mais legível e possibilita o reaproveitamento de código. Programar baseado em funções, é o mesmo que fizer que estamos programando de maneiras estruturada.

def exibir_mensagem():
    print("Olá troxa!!")

def exibir_mensagem_2(nome):
    print(f"Seja bem vindo {nome}")

def exibir_mensagem_3(nome="Thatiane"):
    print(f"Sejá bem vindo(a) {nome}")


exibir_mensagem()
exibir_mensagem_2(nome="Rafael")
exibir_mensagem_3()
exibir_mensagem_3(nome="Rafael")

def calcular_total(numeros):
    return sum(numeros)

def retorna_antecessor_sucessor(numero):
    antecessor = numero -1
    sucessor = numero + 1
    
    return antecessor, sucessor


def fun_3():
    print("Olá troxa!")

print(calcular_total([10, 20,34]))
print(retorna_antecessor_sucessor(10))
print(fun_3())


def salvar_carro(marca, modelo, ano, placa):
    # salva carro no banco de dados...
    print(f"Carro inserido com sucesso! {marca}/{modelo}/{ano}/{placa}")
    print()


salvar_carro("Fiat", "Palio", 1999, "ABC-1234")
salvar_carro(marca="Fiat", modelo="Palio", ano=1999, placa="ABC-1234")
salvar_carro(**{"marca":"Fiat", "modelo":"Pailo", "ano":1999, "placa":"ABC-1234"})

            <!-- Conceito Args e Kwargs  -->
        odemos combinar parâetros obrigatórios com args e kwargs, Quando esse são definidos (*args e **Kwargs), o método recebe os valores como tupla e dicionários respectivamente.


        def exibir_poema(data_exterso, *args, **kwargs):
    texto = "\n".join(args)
    meta_dados = "\n".join([f"{chave.title()}:{valor}" for chave, valor in kwargs.items()])
    mensagem = f"{data_exterso}\n\n{texto}\n\n{meta_dados}"
    print(mensagem)

exibir_poema(
    "Quinta-feira 06 de junho de 2024",
    "Zen of Python",
    "Beautiful is better tha ugly.",
    autor="Tim Peters", ano=1999)

    <!-- Ex Positional only (por posição)-->

            def criar_carro(modelo, ano, placa, /, marca, motor, combustivel):
            print()
            print(modelo, ano, placa, marca, motor, combustivel)
            print()

        criar_carro("Palio", 1999, "ABC-1234", marca="Fiat", motor='1.0', combustivel="Gasolina")

    <!-- Ex: Keyword only (por nome/chave)-->
    
            def criar_carro(*, modelo, ano, placa, marca, motor, combustivel):
            print()
            print(modelo, ano, placa, marca, motor, combustivel)
            print()

        criar_carro(modelo="Palio", ano=1999, placa="ABC-1234", marca="Fiat", motor="1,0", combustivel="Gasolina")

        criar_carro("Palio", 1999, "ABC-1234", marca="Fiat", motor="1,0", combustivel="Gasolina")

    <!-- EX:keyword and positional only (por nome/chave e posição)-->

            def criar_carro(modelo, ano, placa, /, marca, *, motor, combustivel):
            print()
            print(modelo, ano, placa, marca, motor, combustivel)
            print()

        criar_carro("Palio", 1999, "ABC-1234", marca="Fiat", motor="1.0", combustivel="Gasolina")

        criar_carro("Palio", 1999, "ABC-1234", "Fiat", motor="1.0", combustivel="Gasolina")